---
# configs for document itself.
title: "ðŸ‘“Look over at a glance"
lastModified: "2023-04-26"

# field for querying only features at a glance notes.
isLookAtAGlance: true

# add some tags for specifying particular subjects.
tags:
  - "lookAtAGlance"
---
# Based on contents from...
## refactoring guru
| Design Pattern | Target Audience | Applicability | Example Scenario | Implementation Requirements | Implementation Considerations | Pros | Cons | Diagram |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Abstract Factory | OOP programmers | When there is a need to create families of related or dependent objects without specifying their concrete classes. | Creating GUI components that are specific to an operating system, without knowing the details of the operating system. | Knowledge of the families of objects that need to be created, the ability to define abstract classes and interfaces for those objects, and the ability to implement concrete classes that implement those interfaces. | - Define abstract classes or interfaces for each family of related objects. <br> - Implement concrete classes for each family of related objects that implement the corresponding abstract classes or interfaces. <br> - Define an abstract factory interface that declares factory methods for each family of related objects. <br> - Implement concrete factory classes that implement the abstract factory interface and return concrete objects from the corresponding family. | Provides a way to create families of related objects without knowing their concrete classes, and allows for the addition of new families of objects with minimal changes to existing code. | Can lead to increased complexity if there are many families of objects, and can be difficult to add new types of objects to existing families. | UML Class Diagram |
| Adapter | OOP programmers | When there is a need to convert the interface of a class into another interface that clients expect. | Using a third-party library that has an incompatible interface with the rest of the code. | Knowledge of the classes with incompatible interfaces, the ability to define a common interface that the client code expects, and the ability to implement an adapter class that converts the incompatible interface to the common interface. | - Define a common interface that the client code expects. <br> - Implement an adapter class that wraps the incompatible class and implements the common interface. <br> - The client code should use the adapter class instead of the incompatible class. | Provides a way to use incompatible classes together, and allows for the addition of new classes with minimal changes to existing code. | Can lead to increased complexity if there are many incompatible classes, and can affect performance if the adapter needs to do a lot of work to convert the interfaces. | UML Class Diagram |
| Bridge | OOP programmers | When there is a need to separate an abstraction from its implementation so that they can vary independently. | Implementing a GUI framework where the appearance of the widgets needs to be separated from their functionality. | Knowledge of the abstraction and its implementation, the ability to define an abstraction interface and an implementation interface, and the ability to implement concrete classes that implement those interfaces. | - Define an abstraction interface that declares the operations that the client code needs to perform on the abstraction. <br> - Define an implementation interface that declares the operations that the implementation classes need to perform. <br> - Implement concrete classes for the abstraction and the implementation, and have the abstraction class contain a reference to an implementation object. <br> - The client code should use the abstraction interface to perform operations on the abstraction. | Provides a way to separate an abstraction from its implementation, and allows for the addition of new abstractions and implementations with minimal changes to existing code. | Can lead to increased complexity if there are many abstractions and implementations, and can make it difficult to choose the correct abstraction and implementation classes. | UML Class Diagram |
| Builder Pattern | OOP programmers | When there is a need to separate the construction of a complex object from its representation. | Building complex objects that have multiple parts, and where the order of construction matters. | Knowledge of the parts that make up the complex object, the ability to define a builder interface and concrete builder classes, and the ability to define a director class that uses the builder to construct the object. | - Define a builder interface that declares methods for constructing each part of the object. <br> - Implement concrete builder classes that implement the builder interface and construct the object. <br> - Define a director class that uses the builder to construct the object. | Provides a way to construct complex objects step-by-step, allows for the creation of different representations of the same object, and separates the construction logic from the object's class. | Can result in a large number of builder classes, and may be overkill for simple objects. | UML Class Diagram |
| Chain of Responsibility Pattern | OOP programmers | When there is a need to handle a request by multiple objects in a chain, without knowing which object will handle the request. | Handling requests that need to be processed by multiple objects, with each object potentially modifying the request or passing it on to the next object in the chain. | Knowledge of the objects in the chain, the ability to define a handler interface and concrete handler classes, and the ability to link the handlers together in a chain. | - Define a handler interface that declares a method for handling the request and a method for setting the next handler in the chain. <br> - Implement concrete handler classes that implement the handler interface and handle the request or pass it on to the next handler in the chain. <br> - Link the handlers together in a chain by setting the next handler for each handler in the chain. <br> - The client code should create the first handler in the chain and pass the request to it. | Provides a way to handle requests in a flexible and extensible manner, and allows for the separation of request processing logic from the client code. | May result in requests being handled by multiple handlers, which could lead to unintended behavior, and can make it difficult to track the processing of a request. | UML Class Diagram |
| Command Pattern | OOP programmers | When there is a need to encapsulate a request as an object, allowing the request to be parameterized, queued, or logged. | Implementing undo/redo functionality, or implementing a queue of requests. | Knowledge of the objects that will receive the requests, the ability to define a command interface and concrete command classes, and the ability to define a invoker class that executes the commands. | - Define a command interface that declares a method for executing the command. <br> - Implement concrete command classes that implement the command interface and execute the appropriate action on the receiver object. <br> - Define an invoker class that stores the commands and executes them on the receiver object. <br> - The client code should create the commands and add them to the invoker. | Provides a way to decouple the object that sends the request from the object that receives the request, allows for the parameterization and queuing of requests, and allows for the implementation of undo/redo functionality. | Can result in a large number of command classes, and may not be necessary for simple requests. | UML Class Diagram |
| Composite Pattern | OOP programmers | When there is a need to represent part-whole hierarchies of objects. | Representing a hierarchical structure of objects such as a file system, organization chart or a UI control hierarchy. | Knowledge of the object classes that need to be composed, the ability to implement a common interface for all classes in the hierarchy, and the ability to implement methods to add, remove, and access children in each composite class. | - Implement a common interface for all classes in the hierarchy that defines the methods to add, remove, and access children. <br> - Implement methods to add, remove, and access children in each composite class. <br> - Implement methods in the leaf classes that represent the individual objects. | Provides a way to represent part-whole hierarchies of objects in a tree-like structure, and allows for the traversal of the hierarchy and the manipulation of individual objects or groups of objects. | Can lead to increased complexity if the hierarchy is deep, and can make it difficult to enforce type safety if different types of objects are added to the hierarchy. | UML Class Diagram |
| Decorator Pattern | OOP programmers | When there is a need to add new functionality to an object dynamically. | Adding new features to an existing object without modifying its code. | Knowledge of the object that needs to be decorated, the ability to implement a common interface for the object and its decorators, and the ability to implement a decorator class that adds the desired functionality. | - Implement a common interface for the object and its decorators that defines the methods to be decorated. <br> - Implement a decorator class that adds the desired functionality and forwards the calls to the decorated object. <br> - The client code should create the decorated object and wrap it with one or more decorator objects to add the desired functionality. | Provides a way to add new features to an object dynamically without changing its code, and allows for the creation of complex objects with multiple decorators. | Can lead to increased complexity if the number of decorators is large, and can make it difficult to remove decorators from an object once they have been added. | UML Class Diagram |
| Facade Pattern | OOP programmers | When there is a need to provide a simple interface to a complex system or subsystem. | Providing a simple interface to a complex library or API. | Knowledge of the complex system or subsystem that needs to be simplified, the ability to define a facade class that encapsulates the complexity, and the ability to implement methods in the facade class that provide the simplified interface. | - Define a facade class that provides a simple interface to the complex system or subsystem. <br> - Implement methods in the facade class that delegate to the appropriate methods in the complex system or subsystem. <br> - The client code should create an instance of the facade class and call the methods on it to interact with the complex system or subsystem. | Provides a way to simplify a complex system or subsystem and provide a simple interface to it, and allows for the encapsulation of implementation details. | Can lead to a proliferation of facades if different clients need different interfaces to the same system or subsystem. | UML Class Diagram |
| Factory Method Pattern | OOP programmers | When there is a need to create objects without specifying the exact class of object that will be created. | Creating objects that have common behavior or interface but different implementations. | Knowledge of the common behavior or interface that the objects need to have, the ability to define an abstract creator class or interface, and the ability to define concrete creator classes that implement the factory method to create the appropriate object. | - Define an abstract creator class or interface that declares the factory method. <br> - Implement concrete creator classes that implement the factory method to create the appropriate object. <br> - The client code should create an instance of the appropriate concrete creator class and call the factory method on it to create the object. | Provides a way to decouple the client code from the object creation process, and allows for the creation of objects with different implementations of the same behavior or interface. | Can lead to a proliferation of concrete creator classes if there are many different types of objects to create. | UML Class Diagram |
| Flyweight Pattern | OOP programmers | When there is a need to optimize memory usage by sharing common data between multiple objects. | Creating a large number of small objects that have common attributes, such as characters in a word processing program. | Knowledge of the common attributes of the objects, the ability to define a flyweight class that stores these attributes, and the ability to create and manage flyweight objects. | - Define a flyweight class that stores the common attributes of the objects. <br> - Define a factory class that creates and manages flyweight objects. <br> - Modify the client code to use the flyweight objects instead of creating new objects with the same attributes. | Provides a way to reduce memory usage by sharing common data between objects, and allows for the creation of large numbers of objects without consuming excessive memory. | Can lead to increased complexity in the code, and can be difficult to implement for objects with complex state. | UML Class Diagram |
| Iterator Pattern | OOP programmers | When there is a need to traverse an aggregate object and access its elements without exposing its internal representation. | Iterating over a collection of objects, such as a list or an array. | Knowledge of the aggregate object that needs to be traversed, the ability to define an iterator interface and concrete iterator classes, and the ability to implement an iterator method in the aggregate object that returns an iterator object. | - Define an iterator interface that declares methods for accessing the elements of the aggregate object. <br> - Implement concrete iterator classes that implement the iterator interface for the aggregate object. <br> - Implement an iterator method in the aggregate object that returns an iterator object. <br> - The client code should use the iterator object to traverse the aggregate object and access its elements. | Provides a way to access the elements of an aggregate object without exposing its internal representation, and allows for the creation of custom iterators that can iterate over the object in different ways. | Can be difficult to implement for complex aggregate objects, and can lead to increased complexity if the iterators need to maintain state. | UML Class Diagram |
| Mediator Pattern | OOP programmers | When there is a need to decouple the communication between objects by introducing a mediator object that facilitates the communication. | Implementing a chat application where users can send messages to each other. | Knowledge of the objects that need to communicate with each other, the ability to define a mediator interface and concrete mediator classes, and the ability to implement the mediator object that facilitates the communication. | - Define a mediator interface that declares methods for the objects to communicate with each other. <br> - Implement concrete mediator classes that implement the mediator interface and manage the communication between the objects. <br> - Modify the objects to use the mediator object to communicate with each other instead of communicating directly. | Provides a way to decouple the communication between objects and allows for the creation of complex interactions between objects. | Can lead to increased complexity if the mediator object becomes too complex, and can make it difficult to add new objects to the system. | UML Class Diagram |
| Memento Pattern | OOP programmers | When there is a need to capture the state of an object and be able to restore that state later. | Implementing an undo/redo functionality in a text editor. | Knowledge of the objects that need to be able to save and restore their state, the ability to define a memento interface and concrete memento classes, and the ability to implement the caretaker object that manages the mementos. | - Define a memento interface that declares methods for saving and restoring the state of an object. <br> - Implement concrete memento classes that store the state of an object. <br> - Implement the caretaker object that manages the mementos and allows for the undo/redo functionality. <br> - Modify the object to have methods for creating and restoring mementos. | Provides a way to capture and restore the state of an object and allows for the creation of undo/redo functionality. | Can lead to increased memory usage if the mementos are large, and can make it difficult to implement for objects with complex states. | UML Class Diagram |
| Observer Pattern | OOP programmers | When there is a need for objects to be notified of changes to another object's state. | Implementing event handling, such as in a graphical user interface. | Knowledge of the subject that needs to be observed, the ability to define an observer interface and concrete observer classes, and the ability to implement attach/detach and notify methods in the subject class. | - Define an observer interface that declares an update method. <br> - Implement concrete observer classes that implement the update method. <br> - Implement attach/detach and notify methods in the subject class. <br> - The client code should create the subject object and the observer objects, attach the observer objects to the subject object, and call the appropriate methods to update the subject's state. | Provides a way for multiple objects to be notified of changes to another object's state, and allows for loose coupling between the subject and observer objects. | Can lead to performance issues if there are a large number of observers, and can be difficult to implement for complex subject objects. | UML Class Diagram |
| Prototype Pattern | OOP programmers | When there is a need to create new objects by copying existing objects. | Creating objects that are expensive to create or that require a lot of initialization. | Knowledge of the object classes that need to be cloned, the ability to implement a clone method in each object class, and the ability to create new objects by cloning existing objects. | - Implement a clone method in each object class that creates a new object and copies the data from the existing object. <br> - The client code should call the clone method on an existing object to create a new object. | Provides a way to create new objects that are similar to existing objects without the need to create them from scratch, and allows for the creation of complex objects with multiple parts. | Can be difficult to implement for complex objects, and can lead to increased memory usage if the objects are large. | UML Class Diagram |
| Proxy Pattern | OOP programmers | When there is a need to control access to an object or to provide additional functionality to an object without changing its interface. | Controlling access to a resource that is expensive to create or that requires special permissions to access. | Knowledge of the object that needs to be proxied, the ability to create a proxy class that implements the same interface as the object, and the ability to handle calls to the object through the proxy. | - Create a proxy class that implements the same interface as the object. <br> - The proxy class should create and hold a reference to the object. <br> - The proxy class should implement the same methods as the object, and delegate calls to the object as needed. <br> - The proxy class can add additional functionality before or after delegating calls to the object. | Provides a way to control access to an object and to add additional functionality without changing the object's interface, and can be used to implement lazy loading and caching. | Can lead to increased complexity if multiple layers of proxies are used, and can add overhead if the object is accessed frequently. | UML Class Diagram |
| Singleton Pattern | OOP programmers | When there is a need to ensure that only one instance of a class is created and that the instance is easily accessible. | Creating a global configuration object or a logging object that should be shared by all parts of the system. | Knowledge of the class that needs to be made a singleton, the ability to ensure that only one instance of the class is created, and the ability to provide a way to access the instance. | - Ensure that only one instance of the class is created, either by using a private constructor or a static factory method. <br> - Provide a way to access the instance, either through a static method or a global variable. | Ensures that only one instance of a class is created and that the instance is easily accessible, and can be used to manage resources and state that should be shared across the system. | Can make it difficult to test code that uses a singleton, and can introduce hidden dependencies between parts of the system. | UML Class Diagram |
| State Pattern | OOP programmers | When there is a need to change the behavior of an object based on its state, and when there are multiple possible states and transitions between them. | Implementing a vending machine that dispenses different items based on the amount of money inserted and the availability of the items. | Knowledge of the states and transitions between them, the ability to define a state interface and concrete state classes, and the ability to implement a context class that can change its state. | - Define a state interface that declares methods for each possible action that can be performed in that state. <br> - Implement concrete state classes that implement the state interface and define the behavior for each action. <br> - Implement a context class that holds a reference to the current state and delegates all actions to that state. <br> - The client code should create a context object and call its methods to perform actions on the object. | Provides a way to change the behavior of an object based on its state, and allows for the creation of complex state machines with multiple possible states and transitions. | Can lead to increased complexity if there are many states and transitions, and can make it difficult to add new states or transitions. | UML Class Diagram |
| Strategy Pattern | OOP programmers | When there is a need to implement different algorithms for a single task, and when the choice of algorithm should be flexible and configurable. | Implementing sorting algorithms that can be chosen by the user at runtime. | Knowledge of the different algorithms that can be used, the ability to define a strategy interface and concrete strategy classes, and the ability to implement a context class that can use different strategies. | - Define a strategy interface that declares a method for performing the task. <br> - Implement concrete strategy classes that implement the strategy interface and define the algorithm for the task. <br> - Implement a context class that holds a reference to a strategy object and calls its method to perform the task. <br> - The client code should create a context object and set its strategy object to the desired algorithm. | Provides a way to implement different algorithms for a single task, and allows for the choice of algorithm to be flexible and configurable. | Can add complexity to the codebase if there are many strategies, and can make it difficult to add new strategies. | UML Class Diagram |
| Template Method | OOP programmers | When there is a need to define a common algorithm structure but allow subclasses to implement some steps of that algorithm differently. | Creating a framework that performs a series of steps in a specific order but allows customization of some of those steps. | Knowledge of the steps involved in the algorithm, the ability to define a template method that implements the algorithm structure, and the ability to define abstract or virtual methods that can be implemented differently by subclasses. | - Define a template method that calls the abstract or virtual methods to perform the steps of the algorithm. <br> - Implement the abstract or virtual methods in subclasses to provide the custom behavior for specific steps. | Provides a way to define a common algorithm structure while allowing for variation in some steps, and allows for the reuse of code across different implementations of the algorithm. | Can lead to a large number of subclasses if many variations of the algorithm are needed, and can be inflexible if the algorithm structure needs to be changed. | UML Class Diagram |
| Visitor | OOP and FP programmers | When there is a need to define operations that can be performed on an object structure without changing the classes of the objects in that structure. | Implementing algorithms that need to work with different types of objects in an object structure. | Knowledge of the object structure that needs to be visited, the ability to define a visitor interface and concrete visitor classes, and the ability to implement an accept method in each object class that accepts a visitor object. | - Define a visitor interface that declares a visit method for each object class. <br> - Implement concrete visitor classes that implement the visit methods for each object class. <br> - Implement an accept method in each object class that accepts a visitor object and calls the appropriate visit method. <br> - The client code should create a visitor object and call the accept method on the root object in the object structure. | Provides a way to add new operations to an object structure without modifying the classes of the objects in that structure, and allows for the separation of algorithms from the objects they operate on. | Can lead to increased complexity if the object structure is large, and can make it difficult to add new object types to the structure. | UML Class Diagram |

## patterns.dev
| Design Pattern | Target Audience | Applicability | Example Scenario | Implementation Requirements | Implementation Considerations | Pros | Cons | Diagram |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Command Pattern | Developers who want to separate the request for an action from the object that performs the action | When there is a need to decouple the object that requests an action from the object that performs the action, or when there is a need to implement undo and redo functionality. | Implementing a text editor that supports undo and redo functionality. | A command interface, concrete command classes that implement the command interface, an invoker that invokes the command, and a receiver that performs the action specified by the command. | - Define a command interface that specifies the execute method. <br> - Implement concrete command classes that implement the command interface and encapsulate a receiver. <br> - Define an invoker class that invokes the execute method on the command. <br> - Define a receiver class that performs the action specified by the command. | Decouples the object that requests an action from the object that performs the action, and makes it easy to implement undo and redo functionality. | Can add complexity to the code, and may not be necessary for simpler applications. | UML Class Diagram |
| Compound Pattern | Developers who want to combine multiple design patterns to solve complex problems | When there is a need to solve a complex problem that cannot be solved by a single design pattern. | Implementing a complex application that requires multiple design patterns to solve various problems. | Knowledge of multiple design patterns, the ability to combine different design patterns to solve a problem, and the ability to implement each individual design pattern. | - Identify the different problems that need to be solved. <br> - Choose the appropriate design pattern to solve each problem. <br> - Combine the design patterns to solve the overall problem. <br> - Implement each individual design pattern. | Provides a flexible and powerful way to solve complex problems that cannot be solved by a single design pattern. | Can add complexity to the code and may be difficult to implement and maintain. | N/A (as this is not a single, specific design pattern) |
| Container/Presentational | Front-end developers | When there is a need to separate the concerns of how the data is displayed (presentational) from how the data is fetched and manipulated (container). | Implementing a React application that needs to fetch data from an API and display it in various components. | Knowledge of React and Redux, and the ability to create presentational and container components. | - Create presentational components that receive data via props and are responsible for rendering the data. <br> - Create container components that fetch the data and pass it down to the presentational components via props. <br> - Use a state management library like Redux to manage the application state. | Separates concerns of how the data is displayed from how the data is fetched and manipulated, making it easier to reason about and maintain the code. | Can add extra complexity to the code, and may not be necessary for simpler applications. | N/A (as this is not a single, specific design pattern) |
| Factory Pattern | Developers who want to delegate the responsibility of object creation to another class | When there is a need to create objects without exposing the creation logic to the client, or when there is a need to create objects at runtime based on user input. | Creating different types of buttons in a GUI application without exposing the creation logic to the client. | A factory interface, concrete factory classes that implement the factory interface, and product classes that represent the objects being created. | - Define a factory interface that declares a method for creating objects. <br> - Implement concrete factory classes that implement the factory interface and return product objects. <br> - Define product classes that represent the objects being created. | Decouples the client from the creation logic, and makes it easy to create objects at runtime based on user input. | Can add complexity to the code, and may not be necessary for simpler applications. | UML Class Diagram |
| Flyweight Pattern | Developers who want to minimize memory usage | When there is a need to create many objects that have similar properties, and the properties can be shared between objects to reduce memory usage. | Creating a game that needs to render a large number of identical trees in the background. | Knowledge of the objects that need to be created, and the ability to define shared and non-shared properties for those objects. | - Define a flyweight interface that declares methods that use intrinsic (shared) properties. <br> - Define a concrete flyweight class that implements the flyweight interface and contains intrinsic properties. <br> - Define a flyweight factory that creates and manages flyweight objects, and ensures that shared objects are reused. <br> - Define a context class that contains extrinsic (non-shared) properties, and uses the flyweight objects to perform operations. | Reduces memory usage by sharing properties between objects, and can improve performance by reducing the number of objects that need to be created. | Can add complexity to the code, and may not be necessary for simpler applications. | UML Class Diagram |
| HOC Pattern | React developers | When there is a need to reuse component logic and share it between components. | Adding authentication logic to multiple components in a React application. | Knowledge of React and the ability to create higher-order components. | - Define a higher-order component that accepts a component as an argument and returns a new component that wraps the original component. <br> - Add additional logic to the higher-order component, such as authentication or data fetching. <br> - Use the higher-order component to wrap other components that need the additional logic. | Allows for the reuse of component logic, and makes it easy to add additional functionality to components. | Can add complexity to the code, and may not be necessary for simpler applications. | N/A (as this is not a single, specific design pattern) |
| Hooks Pattern | React developers | When there is a need to reuse stateful logic between components without using class components. | Managing state and lifecycle methods in a React function component. | Knowledge of React and the ability to create custom hooks. | - Define a custom hook that encapsulates state and/or lifecycle methods. <br> - Use the custom hook in multiple function components that need the stateful logic. | Allows for the reuse of stateful logic between components without using class components, and simplifies the code by removing the need for HOCs or render props. | Can be difficult to understand and debug, and may require additional knowledge of the React lifecycle. | N/A (as this is not a single, specific design pattern) |
| Mediator/Middleware Pattern | Developers who want to decouple components and improve maintainability | When there is a need to reduce direct coupling between components, and allow for more flexibility in how components interact with each other. | Coordinating interactions between multiple components in a large system. | Knowledge of the components that need to interact, and the ability to define a mediator/middleware. | - Define a mediator/middleware that sits between components and handles communication between them. <br> - Components communicate with the mediator/middleware instead of directly with each other. <br> - The mediator/middleware can perform additional logic such as validation or filtering. | Reduces coupling between components, making it easier to modify and maintain the system. Allows for more flexibility in how components interact with each other. | Can add complexity to the code, and may not be necessary for simpler applications. | UML Class Diagram |
| Mixin Pattern | JavaScript developers | When there is a need to reuse functionality across multiple classes without using inheritance. | Adding logging functionality to multiple classes in a Node.js application. | Knowledge of JavaScript and the ability to create mixins. | - Define a mixin that encapsulates the reusable functionality. <br> - Use the mixin in multiple classes that need the functionality. | Allows for the reuse of functionality across multiple classes without using inheritance, and allows for more flexible composition of classes. | Can lead to code duplication if not used properly, and can be difficult to debug if mixins are used in unexpected ways. | N/A (as this is not a single, specific design pattern) |
| Module Pattern | JavaScript developers | When there is a need to encapsulate functionality and prevent it from polluting the global namespace. | Creating a library of utility functions in a JavaScript application. | Knowledge of JavaScript and the ability to define modules. | - Define a module that encapsulates the functionality. <br> - Export the functions or variables that should be accessible outside of the module. <br> - Import the module in other parts of the application that need the functionality. | Encapsulates functionality and prevents it from polluting the global namespace, making it easier to reason about and maintain the code. | Can be difficult to test if not designed properly, and can lead to increased complexity if modules are not organized properly. | N/A (as this is not a single, specific design pattern) |
| Observer Pattern | OOP programmers | When there is a need for one-to-many communication between objects, where changes to one object trigger updates in other objects. | Implementing a stock market application where changes in stock prices need to be reflected in multiple views. | Knowledge of the objects that need to communicate with each other, and the ability to define interfaces for those objects. | - Define an interface for the observer objects that will receive updates. <br> - Define an interface for the subject object that will be observed. <br> - Implement the subject object and allow observer objects to register with it. <br> - Notify the observer objects when the subject object changes. | Allows for loosely-coupled communication between objects, and can easily accommodate changes in the number or type of observers. | Can lead to performance issues if there are many observers or if observers take a long time to process updates, and can be difficult to debug if the relationships between objects are complex. | UML Class Diagram |
| Prototype Pattern | OOP programmers | When there is a need to create new objects by cloning existing ones, rather than creating them from scratch. | Creating new instances of a complex object that is expensive to create. | Knowledge of the object that needs to be cloned, and the ability to define a clone method for that object. | - Define a clone method for the object that returns a copy of itself. <br> - Implement the clone method for the object. <br> - Use the clone method to create new instances of the object. | Allows for the creation of new objects without the need for a complex initialization process, and can be more efficient than creating objects from scratch. | Can lead to increased memory usage if objects are cloned excessively, and can be difficult to maintain if there are many different types of objects that need to be cloned. | UML Class Diagram |
| Provider | React developers | When there is a need to pass data or functions down through multiple levels of components in a React application. | Passing theme or user data to deeply nested components in a React application. | A data source (such as a state management library) to provide the data, and a Provider component to wrap the child components and pass the data down. | - Define a Provider component that wraps the child components and passes the data down through context. <br> - Use the useContext hook to access the data in the child components. | Provides an easy way to pass data down through multiple levels of components without having to pass props through each level. | Can lead to tight coupling between the Provider and consumer components, and can make it difficult to test the child components in isolation. | N/A |
| Proxy | Software developers | When there is a need for a placeholder or surrogate for another object in order to control access to it or add additional functionality to it. | Controlling access to a sensitive object, such as a database connection or an expensive resource. | An interface or class that defines the methods of the object being proxied, and a proxy object that implements the same interface or class and forwards calls to the original object. | - Define an interface or class that defines the methods of the object being proxied. <br> - Define a proxy object that implements the same interface or class and forwards calls to the original object. <br> - Add additional functionality to the proxy object as needed. | Provides a way to control access to sensitive objects or add additional functionality to them without changing the original object. | Can introduce additional overhead due to the extra layer of indirection, and can make the code more complex to understand and maintain. | UML Class Diagram |
| Render Props Pattern | React developers | When a component needs to share functionality or state with another component in a flexible and reusable way. | Creating a Tooltip component that can be used across multiple components in an application. | A component that defines a render prop method, which takes in a function as an argument and passes the required functionality or state to that function. The component that uses the render prop method needs to define a function that receives the required functionality or state and returns the JSX to be rendered. | - Define a component that requires the shared functionality or state and define a render prop method that takes in a function as an argument. <br> - Define a component that uses the render prop method and defines a function that receives the required functionality or state and returns the JSX to be rendered. <br> - Pass the required functionality or state to the function defined in the component that uses the render prop method. | Provides a flexible and reusable way to share functionality or state between components, and allows components to be composed in a way that is easy to understand and modify. | Can lead to deeply nested code if multiple render props are used, and can be difficult to reason about the flow of data between components. | N/A |
| Singleton Pattern | OOP programmers | When there should be only one instance of a class, and that instance needs to be globally accessible. | A logging class that needs to be globally accessible across an application. | A class that defines a private constructor, a private static instance variable, and a public static getInstance method that returns the instance variable. | - Define a class that has a private constructor, a private static instance variable, and a public static getInstance method that returns the instance variable. <br> - Ensure that the constructor is private so that no other instances of the class can be created. <br> - Use the public static getInstance method to access the single instance of the class. | Provides a way to ensure that only one instance of a class exists, and allows that instance to be globally accessible. | Can lead to increased coupling between classes, and can make it difficult to test classes that depend on the singleton. | UML Class Diagram |