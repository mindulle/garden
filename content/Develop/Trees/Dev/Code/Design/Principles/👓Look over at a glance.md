---
# configs for document itself.
title: "ðŸ‘“Look over at a glance"
lastModified: "2023-04-27"

# field for querying only features at a glance notes.
isLookAtAGlance: true

# add some tags for specifying particular subjects.
tags:
  - "lookAtAGlance"
---
| Principle                       | Description                                                                                                                                                                      | Importance                                              | Benefits                                                                       | Examples                                                                                                                                                   | Best Practices                                                                                   | Bad                                                                       | Good                                                                       |
| ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| SOLID Principles                | A set of five principles for object-oriented software design, including Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion | Improves maintainability, flexibility, and scalability  | Easier to modify and reuse components                                          | Designing classes with a single responsibility, using abstract classes or interfaces to define behavior, using dependency injection to invert dependencies | Apply these principles to achieve better code quality and reduce coupling and complexity         | [[Develop/Trees/Dev/Code/Design/Principles/Go example/SOLID - BAD\|code]] | [[Develop/Trees/Dev/Code/Design/Principles/Go example/SOLID - GOOD\|code]] |
| DRY Principle                   | Don't Repeat Yourself                                                                                                                                                            | Improves maintainability and scalability                | Easier to modify and update code                                               | Refactoring duplicated code into reusable functions or modules, using variables and functions instead of hard-coded values                                 | Avoid duplicating code or logic, and strive for code reuse                                       | [[Develop/Trees/Dev/Code/Design/Principles/Go example/DRY - BAD\|code]]   | [[Develop/Trees/Dev/Code/Design/Principles/Go example/DRY - GOOD\|code]]   |
| KISS Principle                  | Keep it simple, stupid                                                                                                                                                           | Improves maintainability and usability                  | Easier to understand and modify                                                | Removing unnecessary complexity or features, avoiding over-engineering                                                                                     | Refactor complex code to make it simpler                                                         |                                                                           |                                                                            |
| YAGNI Principle                 | You Aren't Gonna Need It                                                                                                                                                         | Avoid implementing functionality that is not needed yet | Improves maintainability and scalability                                       | Easier to modify and reduce the likelihood of introducing bugs                                                                                             | Avoiding premature optimization or adding unnecessary features                                   |                                                                           |                                                                            |
| Law of Demeter                  | Only talk to your immediate friends                                                                                                                                              | Improves maintainability and reduces coupling           | Easier to modify and test code                                                 | Limiting the number of objects that a class interacts with, using method chaining to reduce coupling                                                       | Design classes with limited responsibilities and minimize the dependencies between objects       |                                                                           |                                                                            |
| Composition Over Inheritance    | Favor object composition over class inheritance                                                                                                                                  | Improves flexibility and maintainability                | Easier to modify and reuse components                                          | Using interfaces or abstract classes to define behavior, composing objects to add functionality                                                            | Use design patterns such as the Decorator or Composite pattern                                   |                                                                           |                                                                            |
| Single Responsibility Principle | A class should have only one reason to change                                                                                                                                    | Improves maintainability and reduces coupling           | Easier to modify and test code                                                 | Designing classes with a single responsibility, separating concerns into different classes or modules                                                      | Ensure that each class has a clear and well-defined responsibility                               |                                                                           |                                                                            |
| Open-Closed Principle           | Software entities should be open for extension, but closed for modification                                                                                                      | Improves maintainability and scalability                | Easier to add new functionality without breaking existing code                 | Using abstract classes or interfaces to define behavior, implementing new behavior by adding new classes or methods                                        | Design software to be modular and extensible, using abstractions to reduce coupling              |                                                                           |                                                                            |
| Dependency Inversion Principle  | Depend on abstractions, not concrete implementations                                                                                                                             | Improves flexibility and maintainability                | Easier to change implementation details without affecting the rest of the code | Using interfaces or abstract classes, injecting dependencies via constructors or setters                                                                   | Use design patterns such as the Dependency Injection or Inversion of Control (IoC) pattern       |                                                                           |                                                                            |
| Interface Segregation Principle | A client should not be forced to depend on methods it does not use                                                                                                               | Improves maintainability and reduces coupling           | Easier to modify and test code                                                 | Separating interfaces into smaller, more specialized interfaces, avoiding "fat" interfaces with too many methods                                           | Design interfaces to be focused and cohesive, and avoid exposing unnecessary methods or behavior |                                                                           |                                                                            |
