# Behavioral Design Patterns

Behavioral design patterns are concerned with algorithms and the
assignment of responsibilities between objects.

|                                                                                                  Patterns                                                                                                  | Description                                                                                                                                                                                                                          |
|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/chain-of-responsibility\|Chain Of Responsibility]]*<br/>![50](https://refactoring.guru/images/patterns/cards/chain-of-responsibility-mini.png) | Lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.                                                       |
|                         *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/command\|Command]]*<br/>![50](https://refactoring.guru/images/patterns/cards/command-mini.png)                         | Turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request\'s execution, and support undoable operations. |
|                       *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/iterator\|Iterator]]*<br/>![50](https://refactoring.guru/images/patterns/cards/iterator-mini.png)                        | Lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).                                                                                                                 |
|                      *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/mediator\|Mediator]]* <br/> ![50](https://refactoring.guru/images/patterns/cards/mediator-mini.png)                       | Lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.                                                     |
|                         *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/memento\|Memento]]*<br/>![50](https://refactoring.guru/images/patterns/cards/memento-mini.png)                         | Lets you save and restore the previous state of an object without revealing the details of its implementation.                                                                                                                       |
|                       *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/observer\|Observer]]* <br/>![50](https://refactoring.guru/images/patterns/cards/observer-mini.png)                       | Lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they\'re observing.                                                                                                   |
|                            *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/state\|State]]*<br/>![50](https://refactoring.guru/images/patterns/cards/state-mini.png)                            | Lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.                                                                                                                    |
|                       *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/strategy\|Strategy]]*<br/>![50](https://refactoring.guru/images/patterns/cards/strategy-mini.png)                        | Lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.                                                                                                              |
|             *[[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/template-method\|Template Method]]*<br/>![50](https://refactoring.guru/images/patterns/cards/template-method-mini.png)             | Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.                                                                                  |
|                                                             [[fruit/Coding/Patterns/Design Patterns/catalog/behavioral/visitor\|Visitor]]<br/>![50](https://refactoring.guru/images/patterns/cards/visitor-mini.png)                                                             | Lets you separate algorithms from the objects on which they operate.                                                                                                                                                                 |
